# CertManager Configuration
# Copy this file to ~/.config/cert_manager/config.yml and customize
#
# Cron job example (runs daily at 2am, quiet mode):
#   0 2 * * * /path/to/cert_manager.rb --quiet --yes renew

# Email for Let's Encrypt notifications (required)
email: admin@example.com

# Path to certbot binary (optional, defaults to 'certbot')
certbot_path: certbot

# Certbot directory configuration (all default to ~/.local/share/certbot)
# These avoid needing root access to /etc/letsencrypt
# config_dir: ~/.local/share/certbot        # certificates stored in config_dir/live
# work_dir: ~/.local/share/certbot/work     # certbot working directory
# logs_dir: ~/.local/share/certbot/logs     # certbot log files

# Log level: DEBUG, INFO, WARN, ERROR (optional, defaults to INFO)
log_level: INFO

# Seconds to wait for DNS propagation (optional, defaults to 60)
# Increase this if you experience validation failures
propagation_wait: 60

# Default environment: 'production' or 'staging' (optional, defaults to 'production')
# Staging uses Let's Encrypt test servers - good for testing, no rate limits
# Production issues real, trusted certificates
# Can be overridden per-certificate or via CLI flags (--staging / --production)
environment: production

# DNS Providers
# Configure one or more DNS providers with their credentials
dns_providers:
  # Cloudflare DNS provider
  # Requires an API token with Zone.DNS edit permissions
  # Create at: https://dash.cloudflare.com/profile/api-tokens
  cloudflare_dns:
    type: cloudflare
    api_token: your-cloudflare-api-token-here
    # Optional: specify zone_id to skip automatic zone lookup
    # zone_id: abc123def456

  # Dreamhost DNS provider
  # Requires an API key with dns-* permissions
  # Create at: https://panel.dreamhost.com/index.cgi?tree=home.api
  dreamhost_dns:
    type: dreamhost
    api_key: your-dreamhost-api-key-here

  # AWS Route 53 DNS provider
  # Requires: gem install aws-sdk-route53
  # Get hosted_zone_id from Route 53 console
  route53_dns:
    type: route53
    hosted_zone_id: Z1234567890ABC
    # Optional: explicit credentials (otherwise uses AWS credential chain)
    # access_key_id: AKIAIOSFODNN7EXAMPLE
    # secret_access_key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
    # region: us-east-1

  # GCP Cloud DNS provider
  # Requires: gem install google-apis-dns_v1 googleauth
  # Get managed_zone name from Cloud DNS console
  gcp_dns:
    type: cloud_dns
    project_id: my-gcp-project-123
    managed_zone: my-zone-name
    # Optional: path to service account JSON key file
    # If not provided, uses Application Default Credentials
    # credentials_file: /path/to/service-account.json

  # DNS Made Easy provider
  # Get API credentials from https://dnsmadeeasy.com/ account settings
  dnsmadeeasy_dns:
    type: dnsmadeeasy
    api_key: your-api-key
    secret_key: your-secret-key
    # sandbox: true  # Use sandbox API for testing

# Certificates to manage
# Each certificate defines domains, the DNS provider to use, and optional settings
certificates:
  # Basic single-domain certificate with deployment to target hosts
  - name: webserver
    domains:
      - www.example.com
    dns_provider: cloudflare_dns
    # Deploy certificates to remote hosts via SSH after obtaining/renewing
    # Each target copies fullchain.pem to the path, then reloads the service
    # Optionally set key_path to also copy privkey.pem
    #
    # Supported service types:
    #   nginx  - reloads the 'nginx' systemd unit (default action: reload)
    #   apache - reloads the 'apache2' systemd unit; set service_name for
    #            distros that use 'httpd' (default action: reload)
    #   copy   - copies files only, no service restart
    #            set custom_command to run your own reload/restart command
    #
    # Additional options:
    #   append_key: true  - appends privkey.pem to the cert file for services
    #                       that need a combined PEM (e.g. HAProxy)
    deploy:
      - user: deploy
        host: web1.example.com
        path: /etc/ssl/certs/example.com.crt
        key_path: /etc/ssl/private/example.com.key  # optional
        service: nginx
        action: reload        # reload (default) or restart
        # sudo: false         # omit or set true (default) to use sudo
      - user: deploy
        host: web2.example.com
        path: /etc/ssl/certs/example.com.crt
        service: nginx

  # Apache deploy with custom service name (e.g. RHEL/CentOS uses 'httpd')
  - name: apache-server
    domains:
      - apache.example.com
    dns_provider: cloudflare_dns
    deploy:
      - user: deploy
        host: web3.example.com
        path: /etc/ssl/certs/apache.example.com.crt
        key_path: /etc/ssl/private/apache.example.com.key
        service: apache
        service_name: httpd   # optional, defaults to 'apache2'

  # Local deploy (no SSH, copies files directly on this machine)
  # Useful when cert_manager runs on the same host as the web server
  - name: local-server
    domains:
      - local.example.com
    dns_provider: cloudflare_dns
    deploy:
      - local: true
        path: /etc/ssl/certs/local.example.com.crt
        key_path: /etc/ssl/private/local.example.com.key
        service: nginx
        sudo: false           # set false when running as root or paths are user-writable

  # Copy-only deploy with custom command
  # Useful when the service isn't managed by systemctl
  - name: custom-service
    domains:
      - custom.example.com
    dns_provider: cloudflare_dns
    deploy:
      - user: deploy
        host: custom.example.com
        path: /etc/ssl/certs/custom.example.com.crt
        key_path: /etc/ssl/private/custom.example.com.key
        service: copy
        custom_command: sudo /usr/local/bin/reload-my-service

  # Combined PEM deploy (cert + key in one file, e.g. HAProxy)
  - name: haproxy-server
    domains:
      - ha.example.com
    dns_provider: cloudflare_dns
    deploy:
      - user: deploy
        host: lb1.example.com
        path: /etc/haproxy/certs/ha.example.com.pem
        append_key: true      # appends privkey.pem to the cert file
        service: copy
        custom_command: sudo systemctl reload haproxy

  # Certificate with multiple domains (SAN)
  - name: multi-domain
    domains:
      - example.com
      - www.example.com
      - api.example.com
    dns_provider: cloudflare_dns

  # Wildcard certificate
  # Note: Wildcard certs always require DNS validation
  - name: wildcard
    domains:
      - "*.example.com"
      - example.com
    dns_provider: cloudflare_dns

  # Internal host using DNS alias
  # Use this when the domain being certified can't have public DNS records
  # The ACME challenge is placed at the alias location instead
  - name: internal-server
    domains:
      - server.internal.local
    dns_provider: cloudflare_dns
    # Challenge will be at _acme-challenge.acme.example.com
    # You need a CNAME: _acme-challenge.server.internal.local -> _acme-challenge.acme.example.com
    dns_alias: _acme-challenge.acme.example.com

  # Certificate using staging environment (test certificates)
  # Staging has higher rate limits and doesn't issue real certificates
  # Use 'environment: staging' (preferred) or 'staging: true' (legacy)
  - name: test-cert
    domains:
      - test.example.com
    dns_provider: dreamhost_dns
    environment: staging

  # Production certificate (explicit, same as default)
  - name: production-cert
    domains:
      - prod.example.com
    dns_provider: cloudflare_dns
    environment: production

  # Certificate that reuses existing private key on renewal
  # Useful for HPKP, DANE/TLSA, or when key continuity is required
  - name: pinned-cert
    domains:
      - pinned.example.com
    dns_provider: cloudflare_dns
    reuse_key: true
